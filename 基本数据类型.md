#### Go 数组

数组，是用来存储有序集合数据的。

要想更清晰的了解数组，我们得了解它的内部实现。数组是长度固定的数据类型，必须存储一段相同类型的元素，而且这些元素是连续的。我们这里**强调固定长度**，这是和切片最明显的区别。

数组存储的类型可以是内置类型，比如整形或者字符串，也可以是自定义的数据结构。因为是连续的，所以索引比较好计算，所以我们可以**很快的索引数组中的任何数据**。

##### 声明和初始化

1. 指明存储数据的类型。
2. 存储元素的数量，也就是数组长度。

```go
var array [5]int
```

以上我们声明了一个数组array,但是我们还没有对他进行初始化，这时候数组array里面的值，是对应元素类型的零值，也就是说，**现在这个数组是5个0**。

数组一旦声明后，其元素类型和**大小都不能改变**了。

```go
array := [5]int{1,2,3,4,5}
```

如果我们不想指定数组的长度，可以使用 ... 代替,Go会自动推导数组的长度。

```go
array := [...]int{1,2,3,4,5}
```

如果只想给指定位置初始化

```go
array :=[5]int{1:1,3:4}
```

如果我们要循环打印数组中的所有值，一个传统的就是常用的for循环：

```go
func main() {
    array := [5]int{1: 1, 3: 4}    
    for i := 0; i < 5; i++ {
        fmt.Printf("索引:%d,值:%d\n", i, array[i])
    }
}
```

##### 函数间传递数组

在函数间传递变量时，总是以值的方式，如果变量时个数组，那么就会整个复制，并传递给函数，如果数组非常大，那么对内存的开销会比较大。

```go
func main() {
    array := [5]int{1: 2, 3:4}
    modify(array)
    fmt.Println(array)
}
func modify(a [5]int){
    a[1] =3
    fmt.Println(a)
}
```

如果数组较大，可以传递指针。

```go
func main() {
    array := [5]int{1: 2, 3:4}
    modify(&array)
    fmt.Println(array)
}
func modify(a *[5]int){
    a[1] =3
    fmt.Println(*a)
}
```

这是传递数组的指针的例子，会发现数组被修改了。所以这种情况虽然节省了复制的内存，但是要谨慎使用，因为一不小心，就会修改原数组，导致不必要的问题。

```
这里注意，数组的指针和指针数组是两个概念，数组的指针是*[5]int,指针数组是[5]*int，注意*的位置。
```

#### Go切片

切片也是一种数据结构，它和数组非常相似，因为他时**围绕动态数组的概念设计**的，可以按需自动改变大小，使用这种结构，可以更方便的管理和使用数据集合。

##### 内部实现

切片是基于数组实现的，它的底层是数组，它自己本身非常小，可以理解为对底层数组的抽象。因为基于数组实现，所以它的底层的内存是连续非配的，效率非常高，还可以通过索引获得数据，可以迭代以及垃圾回收优化的好处。

切片对象非常小，是因为它只有3个字段的数据结构：一个是指向底层数组的指针，一个是切片的长度，一个是切片的容量。这3个字段，就是Go语言操作底层数组的元数据，有了它们，我们就可以任意操作切片。

##### 声明和初始化

```go
slice := make([]int,5)
```

使用内置的make函数时，需要传入一个参数，指定切片的长度。当然我们可以单独指定切片的容量。

```go
slice := make([]int,5,10)
```

这时，我们创建的切片长度是5，容量是10，需要注意这个容量10其实对应的是切片底层数组。因为切片的底层是数组，所以创建切片时，如果不指定字面值的话，默认值就是数组的元素的零值。

```
容量必须 >= 长度，我们是不能创建长度大于容量的切片的。
```

字面量创建切片

```go
slice := []int{1,2,3,4,5}
```

切片还有nil切片和空切片，它们的长度和容量都是0，但是它们指向底层数组的指针不一样，nil切片意味着指向底层数组的指针为nil,而空切片对应的指针是个地址。

```go
//nil切片
var nilSlice []int

//空切片
slice := []int{}
```

nil切片表示不存在的切片，而空切片表示一个空集合，它们各有用处。

切片另外一个用处比较多的创建是基于现有的数组或者切片创建。

基于现有的切片或者数组创建，使用[i:j]这样的操作符即可，她表示以i索引开始，到j索引结束，截取原数组或者切片，**对比Java的话，发现和String的substring方法很像**。

i 如果省略，默认是0；j如果省略默认是原数组或者切片的长度，所以例子中的三个新切片的值是一样的。

新的切片和原切片共用的是一个底层数组，所以当修改的时候，底层数组的值就会被改变，所以原切片的值也改变了。当然对于基于数组的切片也一样的。

```
对于底层数组容量是k的切片slice[i:j]来说
长度: j-i
容量: k -i 
Go语言为我们提供了内置的len和cap函数来计算切片的长度和容量。
一种3个索引的方法，第3个用来限定新切片的容量，其用法为slice[i:j:k]
```

##### 使用切片

使用切片，和使用数组一样，通过索引就可以获取切片对应元素的值，同样也可以修改对应元素的值，同样也可以修改对应的元素的值。

```go
slice := []int{1,2,3,4,5}
fmt.Println(slice[2])//获取值
slice[2] = 10 //修改值
fmt.Println(slice[2])//输出10
```

切片只能访问到其长度内的元素，访问超过长度外的元素，会导致运行时异常，与切片容量关联的元素只能用于切片增长。切片算是一个动态数组，所以它可以按需增长，我们使用内置append函数即可。append函数可以为一个切片追加一个元素。

```
slice := []int{1,2,3,4,5}
newSlice := slice[1:3]

newSlice = append(newSlice,10)
fmt.Println(newSlice)
fmt.Println(slice)
```

如果切片的底层数组，没有足够的容量时，就会新建一个底层数组，把原来的数组的值复制到新底层数组里，再追加新值，这时候就不会影响原来的底层数组了。

##### 迭代切片

切片是一个集合，我们可以使用for range 循环来迭代它，打印其中的每个元素以及对应的索引。

```
slice := []int{1,2,3,4,5}
for i,v := range slice {
     fmt.Printf("索引:%d,值:%d\n",i,v)
}
```

如果我们不想要索引，可以使用 _ 来忽略它，这是Go语言的用法。

##### Go Map

Map是一种数据结构，是一个集合，用于存储一系列无序的键值对。它基于键存储的，键就像一个索引一样，这也是Map强大的地方，可以快速检索数据，键指向与该键关联的值。

**Map 存储的是无序的键值对集合。** 

##### 声明和初始化

Map的创建有make函数，Map字面量

```go
dict := make(map[string]int)
```

示例中创建了一个键类型为string的，值类型为int的map。现在创建好之后，这个map是空的，里面什么都没有，我们给存储一个键值对。

```go
dict := make(map[string]int)
dict["zhangsan"] = 43
```

字面量的方式

```go
dict := map[string]int{"张三":43}
dict := map[string]int{"张三":43,"李四":50}
dict := map[string]int{}
```

```go
var dict map[string]int
//这样就好了，但是这样我们是不能操作存储键值对的，必须要初始化后才可以，比如使用make函数，为其开启一块可以存储数据的内存，也就是初始化
dict = make(map[string]int)
dict["张三"] = 43
fmt.Println(dict)
//Map的键可以是任何值，键的类型可以是内置的类型，也可以是结构体类型，但是不管怎么样，这个键可以使用==运算符进行比较，所以像切片、函数以及含有切片的结构类型就不能用于Map的键了，因为他们具有引用的语义，不可比较。
```

Map为我们提供了检测一个键值对是否存在的方法. age,exists := dict["李四"]

删除一个Map中键值对，可以使用Go内置的delete函数

```go
delete(dict,"zhangsan")
//delete 函数删除不存在的键也是可以的，只是没有任何作用
//想要遍历Map的话，可以使用for range 风格的循环，和遍历切片一样。
dict := map[string]int{"zhangsan":43}
for key,value := range dict {
    fmt.Println(key,value)
}
```

这里的range返回两个值，第一个是Map的键，第二个是Map的键对应的值。**遍历是无序的。**

这个例子里有个技巧，`range` 一个Map的时候，也可以使用一个返回值，这个默认的返回值就是Map的键。

```go
func main() {
    dict := map[string]int{"王五": 60, "张三": 43}
    var names []string
    for name := range dict {
        names = append(names, name)
    }
    sort.Strings(names) //排序
    for _, key := range names {
        fmt.Println(key, dict[key])
    }
}
```

##### 在函数间传递Map

函数间传递Map是不会拷贝一个该Map的副本，也就是说如果一个Map传递给一个函数，该函数对这个Map做了修改，那么这个Map的所有引用，都会感知到这个修改。

```go
func main() {
    dict := map[string]int{"王五": 60, "张三": 43}
    modify(dict)
    fmt.Println(dict["张三"])
}
func modify(dict map[string]int) {
    dict["张三"] = 10
}

```

**Map作为函数参数是引用传递。**

#### Go类型

Go语言是一种静态类型的编程语言，所以在编译器进行编译的时候，就要知道每个值的类型，这样编译器就知道要为这个值分配多少内存，并且知道这段分配的内存表示什么。提前知道值的类型的好处有很多，比如编译器可以合理的使用这些值，可以进一步优化代码，提高执行的效率，减少bug等等。

1. 基本类型是值拷贝。
2. 引用类型的地址传递，它的修改可以影响到任何引用到它的变量。在Go语言中，引用类型有切片、map、接口、函数类型以及chan。

引用类型之所以可以引用，是因为他们创建引用类型的变量，其实是一个表头值，表头值里包含一个指针，指向底层的数据结构，当我们在函数中传递引用类型时，其实传递的是这个标头值的副本，它所指向的底层结构并没有被复制传递。

**本质上，我们可以理解函数的传递都是值传递，只不过引用类型传递的是一个指向底层数据的指针，所以我们在操作的时候，可以修改共享的底层数据的值，进而影响到所有引用到这个共享底层数据的变量。**

##### 结构类型

结构类型是用来描述一组值的，比如一个人的身高、体重、名字和年龄等，本质上是一种聚合类型的数据类型。

```go
type person struct {
    age int
    name string 
}

var p person
```

除了基本的原始类型外，结构体内的值也可以是引用类型，或者自定义的其他类型。具体选择类型，要根据实际情况，比如是否准许修改值本身，如果准许的话，可以选择引用类型，如果不不准许的话，则需要使用基本类型。

**函数传参是值传递，所以对于结构体来说也不例外，结构体传递的是其本身以及里面的值的拷贝。**

##### 自定义类型

Go语言支持我们自定义类型，比如上面的结构体类型，就是我们自定义的类型，这也是比较常用的自定义类型的方法。

另外一个自定义类型的方法是基于一个已有的类型，就是基于一个现有的类型创造新的类型，这种也是使用type关键字。

```go
type Duration int64
```

Go的编译器不会像Java的那样，帮我们做隐式的类型转换。















































